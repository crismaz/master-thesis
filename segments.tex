\chapter{Geometric Set Cover with segments}

\section{FPT for segments}
\subsection{Axis-parallel segments}
You can find this in Platypus book. (TODO add referece)

We show on $\mathcal{O}(2^k)$-time branching algorithm.
TODO some introductory text

Let us take
the point $d$ which is the smallest 
among points that are not yet covered
in the lexicographic ordering
of points in $\mathbb{R}^2$.
We need to cover $d$ with some of the remaining segments.

We branch over choice of direction among the 2 axis-parallel directions.
In this direction we greedly take the segment that covers
the most points. As $d$ was the smallest
in lexicographical order, all points in $\points$ colinear with $d$
in both axis-parallel directions 
are only on one side of $d$, because their coordinates are larger.
Therefore
segments covering $d$ in this direction create monotone sequence
of sets and we can greedily take one segment that covers
superset of all of these segments.

TODO: Maybe split it into theorem + algorithm + explanation like in 
section
\ref{segments_in_arbitrary_direction}

TODO: Should it use Remark template?
The same algorithm can be used for segments in $d$ directions,
where we branch over $d$ directions and it runs in complexity $\mathcal{O}(d^k)$.

\subsection{Segments in arbitrary directions}
TODO: lead text

\label{segments_in_arbitrary_direction}
\begin{tw}{
	\label{segment_cover_fpt}
	\textbf{(FPT for segment cover)}.
	There exists an algorithm that given a family $\sets$ of
	$n$ segments (in any direction),
	a set of $m$ points $\points$
	and a parameter $k$,
	runs in time $f(k) \cdot (nm)^c$ for some computable function f and constant c,
	and outputs a subfamily $\sol \subseteq \sets$
	such that $|\sol| \le k$ and $\sol$ covers all points in $\points$,
	or determines that such a set $\sol$ does not exist.
}\end{tw}

We will need the following lemmas.

\begin{lemma}
   \label{fpt_reduction}
   Given a family $\sets$ of
	$n$ segments (in any direction)
	and a set of $m$ points $\points$
	for segment cover problem,
   without a loss of generality we can assume that
   no segment covers a superset of what another segment covers.
   That is, for any distinct $A, B \in \sets$, we have
   $A \cap C \not \subseteq B \cap C$ and $A \cap C \not \supseteq B \cap C$.
\end{lemma}   
   
\begin{proof} Trivial. \end{proof}

\begin{lemma}
	\label{fpt_long_lines}
	Given an instance of a problem, if there exists a line $L$ with at least
	$k+1$ points on it, there exists a subset $\mathcal{A} \subseteq \sets$,
	$|\mathcal{A}| \le k$,
	such that every solution $\sol$ with $|\sol| \le k$
	satisfies $|\mathcal{A} \cap \sol| \ge 1$.
\end{lemma}

\begin{proof}

First we use Lemma \ref{fpt_reduction}.

Let us name points from $\points$ that lay on $L$, $x_1, x_2, \ldots x_t$
in the order they appear on the line.

Every segment that is not colinear with $L$ can cover at most one of these
points. Therefore in any solution of size not larger than $k$,
among any $k$ of these points at least one must
be covered with segment colinear with $L$.

Therefore we need to take one of the segments colinear
with $L$ that covers any of the points
$x_1, x_2, \ldots x_k$. After using reduction from Lemma \ref{fpt_reduction},
there are at most $k$ such segments that are distinct.
\end{proof}



\begin{proof}[Proof of theorem \ref{segment_cover_fpt}.]\leavevmode

%As long as there is a line with more than $k$ points, do branching.
%Let's name points on this line $x_1, x_2, \ldots x_t$
%in order they appear on the line.

%So we choose on which point the chosen segment on this line
%will start. Of course we have to take at least one segment
%covering at least one point among first $k+1$ points,
%because covering all of them with only segments
%on different lines we would use
%exactly $k+1$ segments (any of them can't contain more than
%one point from this line).

\subparagraph{Algorithm.}
First we use Lemma \ref{fpt_reduction}.

We present a recursive algorithm. Given an instance of the problem:

\begin{enumerate}[label={(\arabic*)}]
\item If there exist a line with at least $k+1$ points, we branch over
adding to the solution one of at most $k$ possible segments
from Lemma \ref{fpt_long_lines}, name this segment $S$.
Then we find a solution $\sol$
for problem for points $\points - S$, segments $\sets - \{S\}$
and parameter $k-1$ and return $\sol \cup \{S\}$.
\item If every line has at most $k$ points on it and $|\points| > k^2$,
then answer \texttt{NO}.
\item If $|\points| \le k^2$, solve the problem by brute force algorithm.
\end{enumerate}

\subparagraph{Correctness.}

Lemma \ref{fpt_long_lines} proves that at least one segment that we
branch over in (1) must be present in every solution $\sol$ with $|\sol| \le k$,
therefore the recursive call can find the optimal solution.

In (2) the answer is no, because every line covers no more than $k$ points
from $\points$, which implies that every segment from $\sets$ covers at most
$k$. Under this assumption
we can cover only $k^2$ points with a solution of size $k$, which is less
than $|\points|$.

Checking all possible solutions in (3) is trivially correct.


\subparagraph{Complexity.}

In leaves of branching (3) $|\points| < k^2$, so $|\sets| < k^4$, because
every segments can be uniquely identified by 2 extreme points it covers
(by Lemma \ref{fpt_reduction}). Therefore there are $\binom{k^4}{k}$
possible solutions to check, each can be checked in time $O(k|\points|)$.
Therefore (3) takes time $O(f(k))$.


In this branching algorithm our parameter $k$ is decreased with every
recursive call, so we have at most $k$ levels of recursion with
branching over $k$ possibilites. Candidates to branch over
can be found on each level in time $O(nm \log(nm))$.

Reduction from Lemma \ref{fpt_reduction} can be implemented in $O(n^2m)$.

Overall complexity is $O(n^2m + nm \log(nm) \cdot f(k))$
\end{proof}

